import { AppNode, AppEdge, NodeSubtype, NodeType } from '../types';

// Helper to find connected nodes
const getOutgoers = (nodeId: string, nodes: AppNode[], edges: AppEdge[]): AppNode[] => {
  const outEdgeIds = edges.filter(e => e.source === nodeId).map(e => e.target);
  return nodes.filter(n => outEdgeIds.includes(n.id));
};

export const generateApexSnippet = (node: AppNode): string => {
  const { subtype, properties } = node.data;
  const label = properties.label || 'Unknown';
  const apiName = properties.apiName || label.replace(/\s+/g, '_');
  
  switch (subtype) {
    case NodeSubtype.VAR_PRIMITIVE:
      return `${properties.dataType || 'String'} ${apiName};`;
    case NodeSubtype.VAR_COLLECTION:
      return `List<${properties.dataType || 'String'}> ${apiName}List = new List<${properties.dataType || 'String'}>();`;
    case NodeSubtype.VAR_SOBJECT:
      return `${properties.objectType || 'Account'} ${apiName} = new ${properties.objectType || 'Account'}();`;
    
    case NodeSubtype.LOGIC_TRIGGER:
      return `trigger ${apiName} on ${properties.objectType || 'Account'} (${(properties.triggerEvents || ['before insert']).join(', ')}) {\n    // Logic here\n}`;
    case NodeSubtype.LOGIC_METHOD:
      return `public void ${properties.methodName || 'myMethod'}() {\n    // Method body\n}`;
    
    case NodeSubtype.LOGIC_SOQL:
      return `List<${properties.objectType || 'Account'}> results = [${properties.query || 'SELECT Id FROM Account'}];`;
    case NodeSubtype.LOGIC_DML:
      return `insert ${apiName}; // DML Operation`;
    case NodeSubtype.LOGIC_IF:
      return `if (${properties.condition || 'true'}) {\n    // True block\n} else {\n    // False block\n}`;
    case NodeSubtype.LOGIC_LOOP:
      return `for (${properties.objectType || 'Account'} item : ${properties.collectionName || 'items'}) {\n    // Loop body\n}`;
      
    case NodeSubtype.LWC_WIRE:
      return `@wire(${apiName}) wiredData;`;
    case NodeSubtype.LWC_IMPERATIVE:
      return `${apiName}({ params: ... }).then(result => { ... });`;
      
    case NodeSubtype.INT_REST:
      return `HttpRequest req = new HttpRequest();\nreq.setEndpoint('${properties.endpoint || 'https://api.example.com'}');\nreq.setMethod('GET');\nHttp http = new Http();\nHttpResponse res = http.send(req);`;
      
    default:
      return `// ${label} (${subtype})`;
  }
};

export const generateFullApexCode = (nodes: AppNode[], edges: AppEdge[]): string => {
  let codeLines: string[] = [];
  
  codeLines.push('/**');
  codeLines.push(' * Generated by Architect Force');
  codeLines.push(' * This is a logic skeleton. Implementation details required.');
  codeLines.push(' */\n');

  // 1. Identify "Container" nodes (Triggers, Classes/Methods) vs "Loose" logic
  // For simplicity in this lightweight app, we traverse from top-level logic nodes
  const visited = new Set<string>();

  // Helper to traverse sequence
  const traverse = (currentNode: AppNode, depth: number) => {
    if (visited.has(currentNode.id)) return;
    visited.add(currentNode.id);

    const indent = '    '.repeat(depth);
    const snippet = generateApexSnippet(currentNode);
    
    // Format snippet with indentation
    const indentedSnippet = snippet.split('\n').map(line => indent + line).join('\n');
    codeLines.push(indentedSnippet);

    // Find next nodes (assuming simplified flow: top -> bottom)
    const nextNodes = getOutgoers(currentNode.id, nodes, edges);
    // Sort by Y position to keep logical flow
    nextNodes.sort((a, b) => a.position.y - b.position.y);

    nextNodes.forEach(next => traverse(next, depth));
  };

  // Start with Root nodes (no incoming edges or specific Types)
  const rootNodes = nodes.filter(n => {
    const hasIncoming = edges.some(e => e.target === n.id);
    return !hasIncoming || n.data.type === NodeType.CLOUD || n.data.subtype === NodeSubtype.LOGIC_TRIGGER || n.data.subtype === NodeSubtype.LOGIC_METHOD;
  });

  // Sort roots by Y
  rootNodes.sort((a, b) => a.position.y - b.position.y);

  if (rootNodes.length === 0 && nodes.length > 0) {
     // Cycle or circular dependency handling fallback
     nodes.forEach(n => traverse(n, 0));
  } else {
    rootNodes.forEach(root => {
      traverse(root, 0);
      codeLines.push(''); // Spacer between flows
    });
  }

  return codeLines.join('\n');
};